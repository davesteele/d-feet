From 47a8373580d2f1b9f931ab231b0318ed0f44c39b Mon Sep 17 00:00:00 2001
From: Marcos Marado <mindboosternoori@gmail.com>
Date: Wed, 10 Sep 2014 15:51:32 +0100
Subject: [PATCH] Make pep8 happy

https://bugzilla.gnome.org/show_bug.cgi?id=736422
https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=759223
---
 src/dfeet/addconnectiondialog.py |  6 ++--
 src/dfeet/application.py         |  6 ++--
 src/dfeet/bus_watch.py           | 74 ++++++++++++++++++++--------------------
 src/dfeet/executemethoddialog.py | 30 ++++++++--------
 src/dfeet/introspection.py       | 52 ++++++++++++++--------------
 src/dfeet/settings.py            |  4 +--
 src/dfeet/uiloader.py            |  2 +-
 src/dfeet/window.py              | 12 +++----
 src/dfeet/wnck_utils.py          | 13 +++----
 src/tests/tests.py               |  8 ++---
 10 files changed, 104 insertions(+), 103 deletions(-)

diff --git a/src/dfeet/addconnectiondialog.py b/src/dfeet/addconnectiondialog.py
index 87b71fb..3facf9d 100644
--- a/src/dfeet/addconnectiondialog.py
+++ b/src/dfeet/addconnectiondialog.py
@@ -10,7 +10,7 @@ class AddConnectionDialog:
 
         self.dialog = ui.get_root_widget()
 
-        #get the hbox and add address combo box with model
+        # get the hbox and add address combo box with model
         hbox1 = ui.get_widget('hbox1')
         self.address_combo_box_store = Gtk.ListStore(str)
         self.address_combo_box = Gtk.ComboBox.new_with_model_and_entry(
@@ -21,7 +21,7 @@ class AddConnectionDialog:
         hbox1.pack_start(self.address_combo_box, True, True, 0)
         hbox1.show_all()
 
-        #add history to model
+        # add history to model
         for el in address_bus_history:
             self.address_combo_box_store.append([el])
 
@@ -43,7 +43,7 @@ class AddConnectionDialog:
         if response == Gtk.ResponseType.CANCEL:
             return response
         elif response == Gtk.ResponseType.OK:
-            #check if given address is valid
+            # check if given address is valid
             try:
                 is_supported = Gio.dbus_is_supported_address(self.address)
             except Exception as e:
diff --git a/src/dfeet/application.py b/src/dfeet/application.py
index b469e4e..246670a 100644
--- a/src/dfeet/application.py
+++ b/src/dfeet/application.py
@@ -15,17 +15,17 @@ class DFeetApp(Gtk.Application):
         Gtk.Application.__init__(self, application_id="org.gnome.d-feet",
                                  flags=Gio.ApplicationFlags.FLAGS_NONE)
 
-    #Note that the function in C activate() becomes do_activate() in Python
+    # Note that the function in C activate() becomes do_activate() in Python
     def do_activate(self):
         win = DFeetWindow(self, self.package, self.version, self.data_dir)
 
-    #Note that the function in C startup() becomes do_startup() in Python
+    # Note that the function in C startup() becomes do_startup() in Python
     def do_startup(self):
         Gtk.Application.do_startup(self)
         builder = Gtk.Builder()
         builder.add_from_file(os.path.join(self.data_dir, "ui", "app-menu.ui"))
 
-        #create actions
+        # create actions
         action = Gio.SimpleAction.new("about", None)
         action.connect("activate", self.action_about_cb)
         self.add_action(action)
diff --git a/src/dfeet/bus_watch.py b/src/dfeet/bus_watch.py
index 091f0d5..915d108 100644
--- a/src/dfeet/bus_watch.py
+++ b/src/dfeet/bus_watch.py
@@ -22,23 +22,23 @@ class BusNameBox(Gtk.VBox):
 
         self.__hbox = Gtk.HBox(spacing=5, halign=Gtk.Align.START)
         self.pack_start(self.__hbox, True, True, 0)
-        #icon
+        # icon
         self.__hbox.pack_start(self.__icon_image, True, True, 0)
-        #other information
+        # other information
         self.__vbox_right = Gtk.VBox(spacing=5, expand=True)
         self.__hbox.pack_start(self.__vbox_right, True, True, 0)
 
-        #first element
+        # first element
         self.__label_bus_name = Gtk.Label()
         self.__label_bus_name.set_halign(Gtk.Align.START)
         self.__vbox_right.pack_start(self.__label_bus_name, True, True, 0)
-        #second element
+        # second element
         self.__label_info = Gtk.Label()
         self.__label_info.set_halign(Gtk.Align.START)
         self.__vbox_right.pack_start(self.__label_info, True, True, 0)
-        #separator for the boxes
+        # separator for the boxes
         self.pack_end(Gtk.Separator(orientation=Gtk.Orientation.HORIZONTAL), True, True, 0)
-        #update widget information
+        # update widget information
         self.__update_widget()
         self.show_all()
 
@@ -48,7 +48,7 @@ class BusNameBox(Gtk.VBox):
             self.__label_bus_name.set_markup("<b>{0}</b>".format(self.__bus_name))
         else:
             self.__label_bus_name.set_markup("<b><i>{0}</i></b>".format(self.__bus_name))
-        #update the label info
+        # update the label info
         label_info_str = "<small>"
         if self.__activatable:
             label_info_str += "activatable: yes"
@@ -56,7 +56,7 @@ class BusNameBox(Gtk.VBox):
             label_info_str += "activatable: no"
         if self.__process_id:
             label_info_str += ", pid: {0}".format(self.__process_id)
-            #get the icon (if available)
+            # get the icon (if available)
             if self.__process_id in self.__icon_table.app_map.keys():
                 self.__icon_image.set_from_pixbuf(self.__icon_table.app_map[self.__process_id])
             else:
@@ -94,7 +94,7 @@ class BusNameBox(Gtk.VBox):
     def activatable(self, act_new):
         self.__activatable = act_new
 
-        #update the shown widget
+        # update the shown widget
         self.__update_widget()
 
     @property
@@ -108,7 +108,7 @@ class BusNameBox(Gtk.VBox):
             self.__update_command_line()
         except:
             self.__command_line = ''
-        #update the shown widget
+        # update the shown widget
         self.__update_widget()
 
 
@@ -117,23 +117,23 @@ class BusWatch(object):
     def __init__(self, data_dir, bus_address):
         self.__data_dir = data_dir
         self.__bus_address = bus_address
-        #setup UI
+        # setup UI
         ui = UILoader(self.__data_dir, UILoader.UI_BUS)
         self.__box_bus = ui.get_root_widget()
         self.__scrolledwindow_listbox = ui.get_widget("scrolledwindow_listbox")
         self.__bus_name_filter = ui.get_widget('entry_filter')
-        #create a listbox for all the busnames
+        # create a listbox for all the busnames
         self.__listbox = Gtk.ListBox(hexpand=True, vexpand=True, expand=True)
         self.__listbox.set_sort_func(self.__listbox_sort_by_name, None)
         self.__listbox.set_filter_func(self.__listbox_filter_by_name, None)
         self.__scrolledwindow_listbox.add(self.__listbox)
         self.__scrolledwindow_listbox.show_all()
-        #setup the bus connection
+        # setup the bus connection
         if self.__bus_address == Gio.BusType.SYSTEM or self.__bus_address == Gio.BusType.SESSION:
-            #TODO: do this async
+            # TODO: do this async
             self.connection = Gio.bus_get_sync(self.__bus_address, None)
         elif Gio.dbus_is_supported_address(self.__bus_address):
-            #TODO: do this async
+            # TODO: do this async
             self.connection = Gio.DBusConnection.new_for_address_sync(
                 self.__bus_address,
                 Gio.DBusConnectionFlags.AUTHENTICATION_CLIENT |
@@ -142,19 +142,19 @@ class BusWatch(object):
         else:
             raise ValueError("Invalid bus address '{0}'".format(self.__bus_address))
 
-        #setup signals
+        # setup signals
         self.connection.signal_subscribe(None, "org.freedesktop.DBus", "NameOwnerChanged",
                                          None, None, 0, self.__name_owner_changed_cb, None)
 
-        #refilter if someone wants to filter the busbox list
+        # refilter if someone wants to filter the busbox list
         self.__bus_name_filter.connect("changed",
                                        self.__bus_name_filter_changed_cb)
 
-        #change bus detail tree if a different bus is selected
+        # change bus detail tree if a different bus is selected
         self.__listbox.connect("row-selected",
                                self.__listbox_row_selected_cb)
 
-        #TODO: do this async
+        # TODO: do this async
         self.bus_proxy = Gio.DBusProxy.new_sync(self.connection,
                                                 Gio.DBusProxyFlags.NONE,
                                                 None,
@@ -162,12 +162,12 @@ class BusWatch(object):
                                                 '/org/freedesktop/DBus',
                                                 'org.freedesktop.DBus', None)
 
-        #get a list with activatable names
+        # get a list with activatable names
         self.bus_proxy.ListActivatableNames('()',
                                             result_handler=self.__list_act_names_handler,
                                             error_handler=self.__list_act_names_error_handler)
 
-        #list all names
+        # list all names
         self.bus_proxy.ListNames('()',
                                  result_handler=self.__list_names_handler,
                                  error_handler=self.__list_names_error_handler)
@@ -184,7 +184,7 @@ class BusWatch(object):
     def __listbox_row_selected_cb(self, listbox, listbox_row):
         """someone selected a different row of the listbox"""
         childs = self.box_bus.get_children()
-        #never remove first element - that's the listbox with the busnames
+        # never remove first element - that's the listbox with the busnames
         if len(childs) > 1:
             self.box_bus.remove(childs[-1])
 
@@ -193,11 +193,11 @@ class BusWatch(object):
         except:
             pass
 
-        #get the selected busname
+        # get the selected busname
         if listbox_row:
             row_childs = listbox_row.get_children()
             bus_name_box = row_childs[0]
-            #add the introspection info to the left side
+            # add the introspection info to the left side
             self.__addr_info = AddressInfo(self.__data_dir,
                                            self.__bus_address,
                                            bus_name_box.bus_name,
@@ -232,7 +232,7 @@ class BusWatch(object):
         for listbox_child in self.__listbox.get_children():
             if listbox_child.get_children()[0].bus_name == bus_name:
                 return listbox_child
-        #busname not found
+        # busname not found
         return None
 
     def __listbox_remove_bus_name(self, bus_name):
@@ -240,7 +240,7 @@ class BusWatch(object):
         obj = self.__listbox_find_bus_name(bus_name)
         if obj:
             self.__listbox.remove(obj)
-            #if bus is activatable, add the bus name again
+            # if bus is activatable, add the bus name again
             if bus_name in self.__activatable_names:
                 bnb = BusNameBox(bus_name, '')
                 self.__listbox_add_bus_name(bnb)
@@ -249,23 +249,23 @@ class BusWatch(object):
 
     def __listbox_add_bus_name(self, bus_name_box):
         """add the given busnamebox to the listbox and update the info"""
-        #first check if busname is already listed
-        #ie an activatable (but inactive) busname
+        # first check if busname is already listed
+        # ie an activatable (but inactive) busname
         bn = self.__listbox_find_bus_name(bus_name_box.bus_name)
         if bn:
-            #bus name is already in the list - use this
+            # bus name is already in the list - use this
             bus_name_box = bn.get_children()[0]
         else:
-            #add busnamebox to the list
+            # add busnamebox to the list
             self.__listbox.add(bus_name_box)
 
-        #update bus info stuff
+        # update bus info stuff
         self.bus_proxy.GetConnectionUnixProcessID(
             '(s)', bus_name_box.bus_name,
             result_handler=self.__get_unix_process_id_cb,
             error_handler=self.__get_unix_process_id_error_cb,
             user_data=bus_name_box)
-        #check if bus name is dbus activatable
+        # check if bus name is dbus activatable
         if bus_name_box.bus_name in self.__activatable_names:
             bus_name_box.activatable = True
         else:
@@ -284,7 +284,7 @@ class BusWatch(object):
 
     def __add_names(self, names):
         for n in names:
-            #unique names are added right away
+            # unique names are added right away
             if n[0] == ':':
                 self.__add_name(n, n)
             else:
@@ -300,9 +300,9 @@ class BusWatch(object):
         print("error getting bus names: %s" % str(error))
 
     def __list_act_names_handler(self, obj, act_names, userdata):
-        #remember the activatable bus names
+        # remember the activatable bus names
         self.__activatable_names = act_names
-        #add all activatable bus names to the list
+        # add all activatable bus names to the list
         self.__add_names(act_names)
 
     def __list_act_names_error_handler(self, obj, error, userdata):
@@ -313,8 +313,8 @@ class BusWatch(object):
         bus_name_box.process_id = pid
 
     def __get_unix_process_id_error_cb(self, obj, error, bus_name_box):
-        #print("error getting unix process id for %s: %s" % (
-        #    bus_name_box.bus_name, str(error)))
+        # print("error getting unix process id for %s: %s" % (
+        #     bus_name_box.bus_name, str(error)))
         bus_name_box.process_id = 0
 
     def __listbox_filter_by_name(self, row, user_data):
diff --git a/src/dfeet/executemethoddialog.py b/src/dfeet/executemethoddialog.py
index 0bb5386..31b274e 100644
--- a/src/dfeet/executemethoddialog.py
+++ b/src/dfeet/executemethoddialog.py
@@ -37,12 +37,12 @@ class ExecuteMethodDialog:
         self.label_interface.set_markup("%s" % (self.method_obj.iface_info.name))
 
     def execute_cb(self, widget):
-        #get given parameters
+        # get given parameters
         buf = self.parameter_textview.get_buffer()
         params = buf.get_text(buf.get_start_iter(),
                               buf.get_end_iter(), False)
 
-        #reset the statistics stuff
+        # reset the statistics stuff
         self.label_avg.set_text("")
         self.label_min.set_text("")
         self.label_max.set_text("")
@@ -52,7 +52,7 @@ class ExecuteMethodDialog:
             }
 
         try:
-            #build a GVariant
+            # build a GVariant
             if params:
                 params = "(" + params + ",)"
                 params_code = '(' + self.method_obj.in_args_code + ')'
@@ -68,35 +68,35 @@ class ExecuteMethodDialog:
                                                self.method_obj.object_path,
                                                self.method_obj.iface_info.name,
                                                None)
-                #call the function
+                # call the function
                 for i in range(0, self.method_execution_count_spinbutton.get_value_as_int()):
                     user_data['method_call_time_start'] = time.time()
                     proxy.call(
                         self.method_obj.method_info.name, params_gvariant,
                         Gio.DBusCallFlags.NONE, -1, None, self.method_connection_bus_cb, user_data)
             else:
-                #FIXME: implement p2p connection execution
+                # FIXME: implement p2p connection execution
                 raise Exception("Function execution on p2p connections not yet implemented")
-                #self.connection.call(
-                #None, object_path, self.method_obj.iface_obj.iface_info.name,
-                #self.method_obj.method_info.name, params_gvariant,
-                #GLib.VariantType.new("(s)"), Gio.DBusCallFlags.NONE, -1, None)
+                # self.connection.call(
+                # None, object_path, self.method_obj.iface_obj.iface_info.name,
+                # self.method_obj.method_info.name, params_gvariant,
+                # GLib.VariantType.new("(s)"), Gio.DBusCallFlags.NONE, -1, None)
 
         except Exception as e:
-            #output the exception
+            # output the exception
             self.source_textview.get_buffer().set_text(str(e))
             self.prettyprint_textview.get_buffer().set_text(pformat(str(e)))
 
     def method_connection_bus_cb(self, proxy, res_async, user_data):
         """async callback for executed method"""
         try:
-            #get the result from the dbus method call
+            # get the result from the dbus method call
             result = proxy.call_finish(res_async)
-            #remember the needed time for the method call
+            # remember the needed time for the method call
             method_call_time_end = time.time()
             method_call_time_needed = method_call_time_end - user_data['method_call_time_start']
 
-            #update avg, min, max
+            # update avg, min, max
             user_data['avg'] += method_call_time_needed
             user_data['count'] += 1
             self.label_avg.set_text("%.4f" % (float(user_data['avg'] / user_data['count'])))
@@ -105,7 +105,7 @@ class ExecuteMethodDialog:
             self.label_max.set_text(
                 "%.4f" % max(float(self.label_max.get_text() or "0"), method_call_time_needed))
 
-            #output result
+            # output result
             if result:
                 self.source_textview.get_buffer().set_text(str(result))
                 self.prettyprint_textview.get_buffer().set_text(pformat(result.unpack()[0]))
@@ -113,7 +113,7 @@ class ExecuteMethodDialog:
                 self.prettyprint_textview.get_buffer().set_text(
                     'This method did not return anything')
         except Exception as e:
-            #output the exception
+            # output the exception
             self.source_textview.get_buffer().set_text(str(e))
             self.prettyprint_textview.get_buffer().set_text(pformat(str(e)))
 
diff --git a/src/dfeet/introspection.py b/src/dfeet/introspection.py
index 1000b8f..c6c9144 100644
--- a/src/dfeet/introspection.py
+++ b/src/dfeet/introspection.py
@@ -38,7 +38,7 @@ class AddressInfo():
         self.unique_name = unique_name  # the unique name or None
         self.connection_is_bus = connection_is_bus  # is it a bus or a p2p connection?
 
-        #setup UI
+        # setup UI
         ui = UILoader(self.data_dir, UILoader.UI_INTROSPECTION)
         self.introspect_box = ui.get_root_widget()  # this is the main box with the treeview
         self.__spinner = ui.get_widget('spinner')  # progress during the introspection
@@ -53,10 +53,10 @@ class AddressInfo():
         self.__label_address = ui.get_widget('label_address')
         self.__messagedialog = ui.get_widget('messagedialog')
         self.__messagedialog.connect("close", self.__messagedialog_close_cb)
-        #connect signals
+        # connect signals
         ui.connect_signals(signal_dict)
         if self.connection_is_bus:
-            #we expect a bus connection
+            # we expect a bus connection
             if self.address == Gio.BusType.SYSTEM or self.address == Gio.BusType.SESSION:
                 self.connection = Gio.bus_get_sync(self.address, None)
                 self.__label_address.set_text(
@@ -72,7 +72,7 @@ class AddressInfo():
                 self.connection = None
                 raise Exception("Invalid bus address '%s'" % (self.address))
         else:
-            #we have a peer-to-peer connection
+            # we have a peer-to-peer connection
             if Gio.dbus_is_supported_address(self.address):
                 self.connection = Gio.DBusConnection.new_for_address_sync(
                     self.address,
@@ -83,7 +83,7 @@ class AddressInfo():
                 self.connection = None
                 raise Exception("Invalid p2p address '%s'" % (self.address))
 
-        #start processing data
+        # start processing data
         self.introspect_start()
 
     def __messagedialog_close_cb(self, dialog):
@@ -96,12 +96,12 @@ class AddressInfo():
         obj = model.get_value(iter_, 1)
 
         if isinstance(obj, DBusMethod):
-            #execute the selected method
+            # execute the selected method
             dialog = ExecuteMethodDialog(
                 self.data_dir, self.connection, self.connection_is_bus, self.name, obj)
             dialog.run()
         elif isinstance(obj, DBusProperty):
-            #update the selected property (TODO: do this async)
+            # update the selected property (TODO: do this async)
             proxy = Gio.DBusProxy.new_sync(self.connection,
                                            Gio.DBusProxyFlags.NONE,
                                            None,
@@ -110,9 +110,9 @@ class AddressInfo():
                                            "org.freedesktop.DBus.Properties", None)
             args = GLib.Variant('(ss)', (obj.iface_info.name, obj.property_info.name))
             result = proxy.call_sync("Get", args, 0, -1, None)
-            #update the object value so markup string is calculated correct
+            # update the object value so markup string is calculated correct
             obj.value = result[0]
-            #set new markup string
+            # set new markup string
             model[iter_][0] = obj.markup_str
         else:
             if treeview.row_expanded(path):
@@ -154,9 +154,9 @@ class AddressInfo():
 
     def introspect_start(self):
         """introspect the given bus name and update the tree model"""
-        #cleanup current tree model
+        # cleanup current tree model
         self.__treemodel.clear()
-        #start introspection
+        # start introspection
         self.__dbus_node_introspect("/")
 
     def __button_reload_clicked_cb(self, widget):
@@ -168,22 +168,22 @@ class AddressInfo():
         try:
             res = connection.call_finish(result_async)
         except Exception as e:
-            #got an exception (eg dbus timeout). show the exception
+            # got an exception (eg dbus timeout). show the exception
             self.__messagedialog.set_title("DBus Exception")
             self.__messagedialog.set_property("text", "%s : %s" % (self.name, str(e)))
             self.__messagedialog.run()
             self.__messagedialog.destroy()
         else:
-            #we got a valid result from dbus call! Create nodes and add to treemodel
+            # we got a valid result from dbus call! Create nodes and add to treemodel
             node_info = Gio.DBusNodeInfo.new_for_xml(res[0])
-            #create a GObject node and add to tree-model
+            # create a GObject node and add to tree-model
             tree_iter = None
             if len(node_info.interfaces) > 0:
                 node_obj = DBusNode(self.name, object_path, node_info)
                 tree_iter = self.__treemodel.append(tree_iter, ["%s" % object_path, node_obj])
-                #tree_iter = self.__treemodel.append(tree_iter, ["Hallo", None])
+                # tree_iter = self.__treemodel.append(tree_iter, ["Hallo", None])
 
-                #append interfaces to tree model
+                # append interfaces to tree model
                 name_iter = self.__treemodel.append(tree_iter,
                                                     ["<b>Interfaces</b>", None])
                 for iface in node_info.interfaces:
@@ -191,7 +191,7 @@ class AddressInfo():
                     iface_iter = self.__treemodel.append(
                         name_iter,
                         ["%s" % iface.name, iface_obj])
-                    #interface methods
+                    # interface methods
                     if len(iface.methods) > 0:
                         iface_methods_iter = self.__treemodel.append(
                             iface_iter, ["<b>Methods</b>", None])
@@ -200,7 +200,7 @@ class AddressInfo():
                             self.__treemodel.append(
                                 iface_methods_iter,
                                 ["%s" % method_obj.markup_str, method_obj])
-                    #interface signals
+                    # interface signals
                     if len(iface.signals) > 0:
                         iface_signals_iter = self.__treemodel.append(
                             iface_iter, ["<b>Signals</b>", None])
@@ -209,7 +209,7 @@ class AddressInfo():
                             self.__treemodel.append(
                                 iface_signals_iter,
                                 ["%s" % signal_obj.markup_str, signal_obj])
-                    #interface properties
+                    # interface properties
                     if len(iface.properties) > 0:
                         iface_properties_iter = self.__treemodel.append(
                             iface_iter, ["<b>Properties</b>", None])
@@ -218,7 +218,7 @@ class AddressInfo():
                             self.__treemodel.append(
                                 iface_properties_iter,
                                 ["%s" % property_obj.markup_str, property_obj])
-                    #interface annotations
+                    # interface annotations
                     if len(iface.annotations) > 0:
                         iface_annotations_iter = self.__treemodel.append(
                             iface_iter, ["<b>Annotations</b>", None])
@@ -228,19 +228,19 @@ class AddressInfo():
                                 iface_annotations_iter,
                                 ["%s" % (annotation_obj.markup_str), annotation_obj])
 
-            #are more nodes left?
+            # are more nodes left?
             if len(node_info.nodes) > 0:
                 for node in node_info.nodes:
-                #node_iter = self.__treemodel.append(tree_iter, [node.path, node])
+                    # node_iter = self.__treemodel.append(tree_iter, [node.path, node])
                     if object_path == "/":
                         object_path = ""
                     object_path_new = object_path + "/" + node.path
                     self.__dbus_node_introspect(object_path_new)
             else:
-                #no nodes left. we finished the introspection
+                # no nodes left. we finished the introspection
                 self.__spinner.stop()
                 self.__spinner.set_visible(False)
-                #update name, unique name, ...
+                # update name, unique name, ...
                 self.__label_name.set_text(self.name)
                 self.__label_unique_name.set_text(self.unique_name)
 
@@ -248,10 +248,10 @@ class AddressInfo():
 
     def __dbus_node_introspect(self, object_path):
         """Introspect the given object path. This function will be called recursive"""
-        #start spinner
+        # start spinner
         self.__spinner.start()
         self.__spinner.set_visible(True)
-        #start async dbus call
+        # start async dbus call
         self.connection.call(
             self.name, object_path, 'org.freedesktop.DBus.Introspectable', 'Introspect',
             None, GLib.VariantType.new("(s)"), Gio.DBusCallFlags.NONE, -1,
diff --git a/src/dfeet/settings.py b/src/dfeet/settings.py
index 3c0d008..f521ab0 100644
--- a/src/dfeet/settings.py
+++ b/src/dfeet/settings.py
@@ -5,10 +5,10 @@
 #   portions taken from the Jokosher project
 #
 try:
-    #python2.x
+    # python2.x
     import ConfigParser as configparser
 except:
-    #python3
+    # python3
     import configparser
 import os
 import re
diff --git a/src/dfeet/uiloader.py b/src/dfeet/uiloader.py
index 1a63429..a770a44 100644
--- a/src/dfeet/uiloader.py
+++ b/src/dfeet/uiloader.py
@@ -33,7 +33,7 @@ class UILoader:
         self.ui = Gtk.Builder()
         self.data_dir = data_dir
 
-        #load ui files
+        # load ui files
         for f in ui_info[0]:
             self.ui.add_from_file(self.ui_dir + '/' + f)
 
diff --git a/src/dfeet/window.py b/src/dfeet/window.py
index e500a91..b03b447 100644
--- a/src/dfeet/window.py
+++ b/src/dfeet/window.py
@@ -42,11 +42,11 @@ class DFeetWindow(Gtk.ApplicationWindow):
         self.session_bus = None
         self.system_bus = None
 
-        #setup the window
+        # setup the window
         self.set_default_size(600, 480)
         self.set_icon_name(package)
 
-        #create actions
+        # create actions
         action = Gio.SimpleAction.new('connect-system-bus', None)
         action.connect('activate', self.__action_connect_system_bus_cb)
         self.add_action(action)
@@ -59,13 +59,13 @@ class DFeetWindow(Gtk.ApplicationWindow):
         action.connect('activate', self.__action_connect_other_bus_cb)
         self.add_action(action)
 
-        #get settings
+        # get settings
         settings = Settings.get_instance()
         self.connect('delete-event', self.__delete_cb)
         self.set_default_size(int(settings.general['windowwidth']),
                               int(settings.general['windowheight']))
 
-        #setup ui
+        # setup ui
         ui = UILoader(self.data_dir, UILoader.UI_MAINWINDOW)
         header = ui.get_widget('headerbar')
         self.set_titlebar(header)
@@ -75,13 +75,13 @@ class DFeetWindow(Gtk.ApplicationWindow):
         self.__stack_child_removed_id = self.stack.connect('remove', self.__stack_child_removed_cb)
         self.connect('destroy', self.__on_destroy)
 
-        #create bus history list and load entries from settings
+        # create bus history list and load entries from settings
         self.__bus_history = []
         for bus in settings.general['addbus_list']:
             if bus != '':
                 self.__bus_history.append(bus)
 
-        #add a System and Session Bus tab
+        # add a System and Session Bus tab
         self.activate_action('connect-system-bus', None)
         self.activate_action('connect-session-bus', None)
 
diff --git a/src/dfeet/wnck_utils.py b/src/dfeet/wnck_utils.py
index 4fa37a8..c631793 100644
--- a/src/dfeet/wnck_utils.py
+++ b/src/dfeet/wnck_utils.py
@@ -33,7 +33,7 @@ class IconTable(object):
                 pid = app.get_pid()
                 icon = app.get_mini_icon()
 
-                if not pid in self.app_map.keys():
+                if pid not in self.app_map.keys():
                     self.app_map[pid] = icon
 
     def on_app_open(self, screen, app):
@@ -42,17 +42,18 @@ class IconTable(object):
             self.app_map[app.get_pid()] = icon
 
     def on_app_close(self, screen, app):
-        return  # this is a leak but some apps still exist even if all their
-                # top level windows don't.  We need to have a better cleanup
-                # based on when an app's services go away
+        # this is a leak but some apps still exist even if all their
+        # top level windows don't.  We need to have a better cleanup
+        # based on when an app's services go away
+        return
         pid = app.get_pid()
 
-        if not pid in self.app_map.keys():
+        if pid not in self.app_map.keys():
             del self.app_map[pid]
 
     def get_icon(self, pid):
         icon = None
-        if not pid in self.app_map.keys():
+        if pid not in self.app_map.keys():
             icon = self.app_map[pid]
 
         if not icon:
diff --git a/src/tests/tests.py b/src/tests/tests.py
index 65f243d..f0851ac 100755
--- a/src/tests/tests.py
+++ b/src/tests/tests.py
@@ -66,7 +66,7 @@ class IntrospectionHelperTest(unittest.TestCase):
         obj_prop = DBusProperty(obj_iface, obj_iface.iface_info.properties[0])
         self.assertEqual(obj_prop.name, self.name)
         self.assertEqual(obj_prop.object_path, self.object_path)
-        #get the markup string with value for struct prop (see bgo #702593)
+        # get the markup string with value for struct prop (see bgo #702593)
         obj_prop = DBusProperty(obj_iface, obj_iface.iface_info.properties[2])
         obj_prop.value = ("string", 1, 2)
         self.assertIn("'string', 1, 2", obj_prop.markup_str)
@@ -98,10 +98,10 @@ class AddressInfoTest(unittest.TestCase):
     @unittest.skip("TODO:peer to peer test not implemented")
     def test_peer_to_peer(self):
         """test a p2p connection"""
-        #TODO: setup a gdbus server and test a peer to peer connection
-        #(see http://developer.gnome.org/gio/unstable/GDBusServer.html#gdbus-peer-to-peer)
+        # TODO: setup a gdbus server and test a peer to peer connection
+        # (see http://developer.gnome.org/gio/unstable/GDBusServer.html#gdbus-peer-to-peer)
         pass
 
 if __name__ == "__main__":
-    #run tests
+    # run tests
     unittest.main()
-- 
2.1.0

